@model SchroniskaTurystyczne.Models.SavedRoute

@{
    ViewData["Title"] = "Dodaj Trasę";
}

<h2>@ViewData["Title"]</h2>

<div id="map" style="height: 400px;"></div>

<form asp-controller="Routes" asp-action="Create" method="post">
    <div class="form-group">
        <label asp-for="Name" class="control-label">Nazwa Trasy</label>
        <input asp-for="Name" class="form-control" />
        <span asp-validation-for="Name" class="text-danger"></span>
    </div>

    <div id="routePoints"></div>

    <button type="submit" class="btn btn-primary">Dodaj Trasę</button>
</form>

<h3>Lista Schronisk:</h3>
<ul>
    @if (ViewBag.Shelters != null && ViewBag.Shelters.Count > 0)
    {
        foreach (var shelter in ViewBag.Shelters)
        {
            <li>
                <strong>Nazwa:</strong> @shelter.Name <br />
                <strong>Opis:</strong> @shelter.Description <br />
                <strong>Wystawiający:</strong> @shelter.Exhibitor <br />
                <strong>Współrzędne:</strong> (Lat: @shelter.LocationLat, Lon: @shelter.LocationLon) <br />
            </li>
        }
    }
    else
    {
        <li>Brak schronisk do wyświetlenia.</li>
    }
</ul>

<script>
    const API_KEY = 'EqrphcGjSSf6pg5L1FXub1nmdOe9HzC_FV00UDqrve4';

    const map = new maplibregl.Map({
        container: 'map',
        center: [19.48022053933678, 52.06936257159014],
        zoom: 6,
        style: {
            version: 8,
            sources: {
                'basic-tiles': {
                    type: 'raster',
                    url: `https://api.mapy.cz/v1/maptiles/basic/tiles.json?apikey=${API_KEY}`,
                    tileSize: 256,
                },
                'route-geometry': {
                    type: 'geojson',
                    data: {
                        type: "LineString",
                        coordinates: [],
                    },
                },
            },
            layers: [{
                id: 'tiles',
                type: 'raster',
                source: 'basic-tiles',
            }, {
                id: 'route-geometry',
                type: 'line',
                source: 'route-geometry',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round',
                },
                paint: {
                    'line-color': '#0033ff',
                    'line-width': 8,
                    'line-opacity': 0.6,
                },
            }],
        },
    });

    const shelters = @Html.Raw(Json.Serialize(ViewBag.Shelters));
    console.log(shelters);

    function addShelterMarkers(shelters) {

        if (shelters.length === 0) {
            console.warn("Brak schronisk.");
            return;
        }

        shelters.forEach(shelter => {

            //const markerElement = document.createElement('div');
            //markerElement.className = 'custom-marker';

            const marker = new maplibregl.Marker({color: 'yellow'})
                .setLngLat([parseFloat(shelter.locationLon), parseFloat(shelter.locationLat)])
                .setPopup(new maplibregl.Popup({ offset: 25 })
                    .setHTML(`
                        <h3>${shelter.name}</h3>
                        <p>${shelter.description}</p>
                        <p>Wystawiający: ${shelter.exhibitor}</p>
                    `))
                .addTo(map);
        });
    }

    map.on('load', function () {
        console.log("Mapa załadowana, dodawanie markerów");
        addShelterMarkers(shelters);
    });

    let routePoints = [];
    let markers = [];

    map.on('click', function (e) {
        const coords = [e.lngLat.lng, e.lngLat.lat];

        routePoints.push(coords);

        console.log(`Dodano punkt: Lat: ${coords[1]}, Lon: ${coords[0]}`);

        addMarker(coords, routePoints.length - 1);

        if (routePoints.length > 1) {
            calculateRoute(routePoints);
        }

        updateRoutePointsInput(routePoints);
    });

    function addMarker(coords, index) {
        const marker = new maplibregl.Marker({ draggable: true })
            .setLngLat(coords)
            .addTo(map);

        markers.push(marker);

        marker.on('dragend', function () {
            const newCoords = marker.getLngLat();
            routePoints[index] = [newCoords.lng, newCoords.lat];

            console.log(`Lat: ${newCoords.lat}, Lon: ${newCoords.lng}`);

            if (routePoints.length > 1) {
                calculateRoute(routePoints);
            }

            updateRoutePointsInput(routePoints);
        });
    }

    function updateRoutePointsInput(points) {
        const routePointsDiv = document.getElementById('routePoints');
        routePointsDiv.innerHTML = '';

        const pointsArray = points.map((point, index) => ({
            LocationLat: point[1],
            LocationLon: point[0],
            Number: index + 1
        }));

        const jsonInput = document.createElement('input');
        jsonInput.type = 'hidden';
        jsonInput.name = 'routePointsJson';
        jsonInput.value = JSON.stringify(pointsArray);

        routePointsDiv.appendChild(jsonInput);

        pointsArray.forEach(point => {
            console.log(`Punkt ${point.Number}: Lat: ${point.LocationLat}, Lon: ${point.LocationLon}`);
        });
    }

    //obliczanie trasy przy użyciu API Mapy.cz
    async function calculateRoute(points) {
        try {
            const url = new URL('https://api.mapy.cz/v1/routing/route');

            url.searchParams.set('apikey', API_KEY);
            url.searchParams.set('lang', 'pl');
            url.searchParams.set('routeType', 'foot_fast');
            url.searchParams.set('avoidToll', 'false');

            url.searchParams.set('start', points[0].join(','));

            url.searchParams.set('end', points[points.length - 1].join(','));

            for (let i = 1; i < points.length - 1; i++) {
                url.searchParams.append('waypoints', points[i].join(','));
            }

            const response = await fetch(url.toString(), { mode: 'cors' });
            const json = await response.json();

            const source = map.getSource('route-geometry');
            if (source && json.geometry) {
                source.setData(json.geometry);
            }

            const bounds = bbox(json.geometry.geometry.coordinates);
            map.fitBounds(bounds, { padding: 40 });
        } catch (error) {
            console.log('Błąd podczas wyznaczania trasy:', error);
        }
    }

    //przybliżanie do trasy
    function bbox(coords) {
        let minLat = Infinity, minLng = Infinity, maxLat = -Infinity, maxLng = -Infinity;

        coords.forEach(coord => {
            minLng = Math.min(coord[0], minLng);
            maxLng = Math.max(coord[0], maxLng);
            minLat = Math.min(coord[1], minLat);
            maxLat = Math.max(coord[1], maxLat);
        });

        return [[minLng, minLat], [maxLng, maxLat]];
    }
</script>