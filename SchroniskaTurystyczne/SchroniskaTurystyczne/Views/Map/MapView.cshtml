@model IEnumerable<SchroniskaTurystyczne.Models.Shelter>
@{
    ViewData["Title"] = "Mapa Schronisk";
    var selectedShelterId = ViewBag.SelectedShelterId ?? "";  // ID wybranego schroniska, jeśli istnieje
}

<div class="map-container">
    <!-- Mapa -->
    <div id="map" class="map-area"></div>

    <!-- Interfejs użytkownika -->
    <div class="sidebar">
        <h2>@ViewData["Title"]</h2>

        <!-- Zakładki nawigacyjne -->
        <div class="tabs">
            <button onclick="showSection('searchSection')" class="tab-button active">Szukanie noclegu</button>
            <button onclick="showSection('planSection')" class="tab-button">Planowanie trasy</button>
            <button onclick="showSection('savedRoutesSection')" class="tab-button">Moje trasy</button>
        </div>

        <!-- Sekcja Szukanie noclegu -->
        <div id="searchSection" class="tab-content active p-3 rounded bg-light shadow">
            <h4 class="mb-3 text-darkcyan">Szukaj noclegu</h4>
            <input type="text" id="searchInput" placeholder="Wpisz miejscowość" class="form-control mb-3" />
            <select id="searchType" class="form-control mb-3">
                <option value="regional">Wybierz Tagi</option>
                <option value="regional.country">Kraj</option>
                <option value="regional.region">Region</option>
                <option value="regional.street">Ulica</option>
                <option value="regional.address" selected>Adres</option>
            </select>
            <select id="searchType" class="form-control mb-3">
                <option value="regional">Wybierz typ pokoju</option>
                <option value="regional.country">Kraj</option>
                <option value="regional.region">Region</option>
                <option value="regional.street">Ulica</option>
                <option value="regional.address" selected>Adres</option>
            </select>
            <div class="d-flex gap-2">
                <button class="dark-darkcyan-button" onclick="searchLocation()">Szukaj</button>
                <!--<button class="btn btn-secondary" onclick="fitToAllMarkers()">Wyświetl wszystkie schroniska</button>-->
            </div>
        </div>

        <!-- Sekcja Planowanie trasy -->
        <div id="planSection" class="tab-content p-3 rounded bg-light shadow mt-4">
            <h4 class="mb-3 text-darkcyan">Planowanie Trasy</h4>
            <div class="d-flex gap-2 mb-3">
                <button class="dark-darkcyan-button" onclick="toggleRouteCreation()">Tryb Tworzenia Trasy</button>
                <button class="btn btn-secondary" onclick="clearRoute()">Wyczyść Trasę</button>
            </div>
            <!--<div id="travelTimeDisplay" class="mt-2 text-darkcyan"></div>
            <select id="travelMode" class="form-control mb-3">
                <option value="foot_fast">Pieszo</option>
                <option value="bicycle">Rowerem</option>
            </select>-->
            <form id="routeForm" asp-controller="Routes" asp-action="Create" method="post" class="mt-3">
                <div class="form-group mb-3">
                    <label for="routeName" class="form-label">Nazwa Trasy</label>
                    <input id="routeName" name="Name" class="form-control" />
                </div>
                <div id="routePoints"></div>
                <button type="submit" class="aquamarine-button">Zapisz Trasę</button>
            </form>
        </div>

        <!-- Sekcja Moje trasy -->
        <div id="savedRoutesSection" class="tab-content p-3 rounded bg-light shadow mt-4">
            <h4 class="mb-3 text-darkcyan">Twoje Zapisane Trasy</h4>
            <div id="userRoutesList" class="mb-3">
                <!-- W tym miejscu pojawią się zapisane trasy użytkownika -->
            </div>
        </div>
    </div>
</div>

<script>
    const API_KEY = 'EqrphcGjSSf6pg5L1FXub1nmdOe9HzC_FV00UDqrve4';
    const shelters = @Html.Raw(Json.Serialize(Model));
    const selectedShelterId = "@selectedShelterId";

    const map = new maplibregl.Map({
        container: 'map',
        center: [19.48022053933678, 52.06936257159014],
        zoom: 6,
        style: {
            version: 8,
            sources: {
                'basic-tiles': {
                    type: 'raster',
                    url: `https://api.mapy.cz/v1/maptiles/basic/tiles.json?apikey=${API_KEY}`,
                    tileSize: 256,
                },
                'route-geometry': {
                    type: 'geojson',
                    data: {
                        type: "LineString",
                        coordinates: [],
                    },
                },
            },
            layers: [{
                id: 'tiles',
                type: 'raster',
                source: 'basic-tiles',
            }, {
                id: 'route-geometry',
                type: 'line',
                source: 'route-geometry',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round',
                },
                paint: {
                    'line-color': 'darkcyan',
                    'line-width': 8,
                    'line-opacity': 1,
                },
            }],
        },
    });

    let routePoints = [];
    let markers = [];
    let isCreatingRoute = false;

    // Funkcja do dodania markerów na mapie
    function addShelterMarkers(shelters) {
        shelters.forEach(shelter => {
            const marker = new maplibregl.Marker({ color: shelter.id == selectedShelterId ? 'red' : 'yellow' })
                .setLngLat([parseFloat(shelter.locationLon), parseFloat(shelter.locationLat)])
                .setPopup(new maplibregl.Popup({ offset: 25 })
                    .setHTML(`
                        <h3 style="margin-top: 0;">${shelter.name}</h3>
                        <p style="margin: 5px 0;">Ocena: ${shelter.rating}</p>
                        <p style="margin: 5px 0;">Tagi: </p>
                        <a href="/Booking/Index/${shelter.id}"
                           style="display: inline-block; padding: 8px 12px; background-color: darkcyan; color: white; text-decoration: none; border-radius: 4px; text-align: center;">
                            Szczegóły
                        </a>`))
                .addTo(map);
        });

        if (selectedShelterId) {
            const selectedShelter = shelters.find(s => s.id == selectedShelterId);
            if (selectedShelter) {
                map.setCenter([parseFloat(selectedShelter.locationLon), parseFloat(selectedShelter.locationLat)]);
                map.setZoom(12);
            }
        }
    }

    // Funkcja przełączająca tryb tworzenia trasy
    function toggleRouteCreation() {
        isCreatingRoute = !isCreatingRoute;
        console.log(isCreatingRoute ? "Tryb tworzenia trasy włączony" : "Tryb tworzenia trasy wyłączony");
    }

    // Dodaj marker i trasę na kliknięcie, gdy tryb tworzenia trasy jest włączony
    map.on('click', function (e) {
        if (!isCreatingRoute) return;

        const coords = [e.lngLat.lng, e.lngLat.lat];
        routePoints.push(coords);
        addRouteMarker(coords, routePoints.length - 1);

        if (routePoints.length > 1) {
            calculateRoute(routePoints);
        }

        updateRoutePointsInput(routePoints);
    });

    // Dodaj marker dla punktu trasy
    function addRouteMarker(coords, index) {
        const marker = new maplibregl.Marker({ draggable: true })
            .setLngLat(coords)
            .addTo(map);

        markers.push(marker);

        marker.on('dragend', function () {
            const newCoords = marker.getLngLat();
            routePoints[index] = [newCoords.lng, newCoords.lat];

            if (routePoints.length > 1) {
                calculateRoute(routePoints);
            }

            updateRoutePointsInput(routePoints);
        });
    }

    // Funkcja, aby dopasować mapę do wszystkich markerów
    function fitToAllMarkers() {
        const bounds = new maplibregl.LngLatBounds();
        shelters.forEach(shelter => bounds.extend([parseFloat(shelter.locationLon), parseFloat(shelter.locationLat)]));
        map.fitBounds(bounds, { padding: 20 });
    }

    // Funkcja aktualizująca input dla punktów trasy
    function updateRoutePointsInput(points) {
        const routePointsDiv = document.getElementById('routePoints');
        routePointsDiv.innerHTML = '';

        const pointsArray = points.map((point, index) => ({
            LocationLat: point[1],
            LocationLon: point[0],
            Number: index + 1
        }));

        const jsonInput = document.createElement('input');
        jsonInput.type = 'hidden';
        jsonInput.name = 'routePointsJson';
        jsonInput.value = JSON.stringify(pointsArray);

        routePointsDiv.appendChild(jsonInput);

        pointsArray.forEach(point => {
            console.log(`Punkt ${point.Number}: Lat: ${point.LocationLat}, Lon: ${point.LocationLon}`);
        });
    }

    // Obliczanie i rysowanie trasy
    async function calculateRoute(points) {
        try {
            const url = new URL('https://api.mapy.cz/v1/routing/route');

            url.searchParams.set('apikey', API_KEY);
            url.searchParams.set('lang', 'pl');
            url.searchParams.set('routeType', 'foot_fast');
            url.searchParams.set('avoidToll', 'false');

            url.searchParams.set('start', points[0].join(','));

            url.searchParams.set('end', points[points.length - 1].join(','));

            for (let i = 1; i < points.length - 1; i++) {
                url.searchParams.append('waypoints', points[i].join(','));
            }

            const response = await fetch(url.toString(), { mode: 'cors' });
            const json = await response.json();

            const source = map.getSource('route-geometry');
            if (source && json.geometry) {
                source.setData(json.geometry);
            }

            const bounds = bbox(json.geometry.geometry.coordinates);
            map.fitBounds(bounds, { padding: 40 });
        } catch (error) {
            console.log('Błąd podczas wyznaczania trasy:', error);
        }
    }

    function bbox(coords) {
        let minLat = Infinity, minLng = Infinity, maxLat = -Infinity, maxLng = -Infinity;
        coords.forEach(coord => {
            minLng = Math.min(coord[0], minLng);
            maxLng = Math.max(coord[0], maxLng);
            minLat = Math.min(coord[1], minLat);
            maxLat = Math.max(coord[1], maxLat);
        });
        return [[minLng, minLat], [maxLng, maxLat]];
    }

    // Czyszczenie trasy
    function clearRoute() {
        routePoints = [];
        markers.forEach(marker => marker.remove());
        markers = [];
        console.log("Trasa wyczyszczona");
    }

    async function searchLocation() {
        const query = document.getElementById('searchInput').value;
        if (!query) return alert('Wpisz nazwę miejscowości!');

        const lang = 'pl';
        const limit = 5;
        const type = document.getElementById('searchType').value;  // Ustaw typ wyszukiwania na podstawie wyboru użytkownika

        try {
            const url = `https://api.mapy.cz/v1/geocode?query=${encodeURIComponent(query)}&lang=${lang}&limit=${limit}&type=${type}&apikey=${API_KEY}`;

            const response = await fetch(url);
            console.log(response);
            const data = await response.json();
            console.log(data);

            if (data && data.features && data.features.length > 0) {
                const location = data.features[0].geometry.coordinates;
                map.setCenter(location);
                map.setZoom(12);
            } else {
                alert("Nie znaleziono miejscowości.");
            }
        } catch (error) {
            console.error("Błąd podczas wyszukiwania miejscowości:", error);
            alert("Wystąpił problem z wyszukiwaniem. Spróbuj ponownie.");
        }
    }

    function showSection(sectionId) {
        // Ukryj wszystkie sekcje
        const tabContents = document.querySelectorAll('.tab-content');
        tabContents.forEach(tab => tab.classList.remove('active'));

        // Usuń klasę aktywną ze wszystkich przycisków zakładek
        const tabButtons = document.querySelectorAll('.tab-button');
        tabButtons.forEach(button => button.classList.remove('active'));

        // Pokaż wybraną sekcję i ustaw aktywny przycisk
        document.getElementById(sectionId).classList.add('active');

        // Dodaj klasę active do klikniętego przycisku
        event.target.classList.add('active');
    }

    /*async function calculateRoute(points) {
        try {
            const travelMode = document.getElementById("travelMode").value; // Pobierz tryb podróży
            const url = new URL('https://api.mapy.cz/v1/routing/route');

            url.searchParams.set('apikey', API_KEY);
            url.searchParams.set('lang', 'pl');
            url.searchParams.set('routeType', travelMode); // Użyj wybranego trybu podróży
            url.searchParams.set('avoidToll', 'false');

            url.searchParams.set('start', points[0].join(','));
            url.searchParams.set('end', points[points.length - 1].join(','));

            for (let i = 1; i < points.length - 1; i++) {
                url.searchParams.append('waypoints', points[i].join(','));
            }

            const response = await fetch(url.toString(), { mode: 'cors' });
            const json = await response.json();

            const source = map.getSource('route-geometry');
            if (source && json.geometry) {
                source.setData(json.geometry);
            }

            const bounds = bbox(json.geometry.geometry.coordinates);
            map.fitBounds(bounds, { padding: 40 });

            // Wyciągnij i wyświetl czas trwania podróży
            const travelTime = json.routeSummary.travelTime; // Czas w sekundach
            displayTravelTime(travelTime);

        } catch (error) {
            console.log('Błąd podczas wyznaczania trasy:', error);
        }
    }

    // Funkcja do wyświetlenia czasu podróży
    function displayTravelTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const timeDisplay = hours > 0 ? `${hours} godz. ${minutes} min.` : `${minutes} min.`;

        const travelTimeElement = document.getElementById("travelTimeDisplay");
        travelTimeElement.textContent = `Czas podróży: ${timeDisplay}`;
    }*/

    /*async function loadUserRoutes() {
        const userId = '';
        try {
            const response = await fetch(`/Routes/GetUserRoutes?userId=${userId}`);
            const routes = await response.json();
            displayRoutes(routes);
        } catch (error) {
            console.error("Błąd podczas pobierania tras:", error);
        }
    }

    function displayRoutes(routes) {
        const routesList = document.getElementById('userRoutesList');
        routesList.innerHTML = '';

        if (routes.length === 0) {
            routesList.innerHTML = '<p>Nie masz zapisanych tras.</p>';
            return;
        }

        routes.forEach(route => {
            const routeElement = document.createElement('div');
            routeElement.classList.add('route-item', 'mb-3', 'p-2', 'border', 'rounded');
            routeElement.innerHTML = `
                <h5>${route.name}</h5>
                <p>Punkty trasy:</p>
                <ul>
                    ${route.points.map(point => `<li>${point.name || 'Punkt'} - (${point.locationLat}, ${point.locationLon})</li>`).join('')}
                </ul>
            `;
            routesList.appendChild(routeElement);
        });
    }

    document.addEventListener('DOMContentLoaded', loadUserRoutes);*/

    map.on('load', function () {
        addShelterMarkers(shelters);
    });
</script>